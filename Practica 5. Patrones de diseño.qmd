---
title: "Practica 5. Patrones de dise침o"
author: "robles danna michell"
date: "29/09/2025"
format: pdf
---
# Practica 5. Patrones de dise침o
# Singler

r```{python}
# Practica 5. Patrones de dise침o
# Singleton

class Logger: 
    # creamos un atributo de clase donde se aguardar치 la 칰nica instancia 
    _instancia = None 

    # __new__ es el m칠todo que controla la creaci칩n del objeto antes de init.
    # Sirve para asegurarnos de que solo exista una 칰nica instancia de la clase Logger 
    def __new__(cls, *args, **kwargs):
        if cls._instancia is None: 
            cls._instancia = super().__new__(cls)
            # creamos atributo "archivo" que apunta a un archivo f칤sico
            # "a" significa append = todo lo que se escriba se agrega al final del archivo
            cls._instancia.archivo = open("app.log", "a")
        return cls._instancia  # devolvemos siempre la misma instancia

    def log(self, mensaje):
        self.archivo.write(mensaje + "\n")
        self.archivo.flush()  # asegura que se guarde en el disco

logger1 = Logger()  # primera y 칰nica instancia 
logger2 = Logger()  # devuelve la misma instancia

logger1.log("Inicio de sesi칩n en la aplicaci칩n")
logger2.log("El usuario se autentic칩")

# comprobar que son el mismo objeto en memoria
print(logger1 is logger2)


# Actividad de la pr치ctica

class Presidente:
    _instancia = None  # 游녣 faltaba declarar la variable de clase

    def __new__(cls, nombre):
        if cls._instancia is None:
            cls._instancia = super().__new__(cls)
            cls._instancia.nombre = nombre
            cls._instancia.historial = []
        return cls._instancia   # 游녣 aqu칤 estaba mal escrito (ten칤as __instancia)

    def accion(self, accion):  # 游녣 corregido el nombre del m칠todo (antes "aacion")
        evento = f"{self.nombre} {accion}"
        self.historial.append(evento)
        print(evento)

# Varios presidentes intentan tomar el poder 
p1 = Presidente("AMLO")
p2 = Presidente("Pe침a Nieto")
p3 = Presidente("Fox")

# Todos apuntan al mismo presidente 
p1.accion("firm칩 decreto")
p2.accion("visit칩 Espa침a")
p3.accion("aprob칩 un presupuesto")

print("\nHistorial del presidente")
print(p1.historial)

# Validaci칩n de Singleton
print(p1 is p2 is p3)  # True o False

```

1. 쯈u칠 pasar칤a si eliminamos la verificaci칩n if cls._instancia is None en el m칠todo __new__?

Si quitamos esa l칤nea, cada vez que creemos un objeto se generar칤a uno nuevo y distinto, en vez de reutilizar siempre el mismo.
Eso significa que ya no tendr칤amos un 칰nico presidente, sino varios diferentes (p1, p2, p3), rompiendo la idea principal del patr칩n Singleton, que es garantizar que solo exista una instancia en todo el programa.

2. 쯈u칠 significa el True en p1 is p2 is p3 en el contexto del m칠todo Singleton?

En Python, el operador is no compara valores, sino si dos variables apuntan al mismo lugar en memoria.
Entonces, que salga True quiere decir que p1, p2 y p3 en realidad son el mismo objeto disfrazado con distintos nombres.
Eso confirma que el Singleton est치 funcionando: aunque pareciera que tenemos tres presidentes, en verdad solo existe uno.

3. 쮼s buena idea usar Singleton para todo lo que sea global?

No, no es buena idea abusar de este patr칩n. El Singleton es muy 칰til cuando de verdad solo debe existir un 칰nico recurso en todo el sistema, por ejemplo:

Un logger que guarda los eventos de la aplicaci칩n.
La conexi칩n principal a una base de datos.
Un gestor de configuraci칩n que maneje par치metros globales.
Pero no ser칤a recomendable usarlo en casos donde cada objeto debe ser independiente y 칰nico, como:
Modelar usuarios en una red social (cada usuario debe ser diferente).
Modelar autos en un sistema de tr치nsito (cada coche tiene sus propios atributos).

El Singleton es poderoso, pero si lo usamos para todo, el dise침o se vuelve r칤gido y dif칤cil de mantener.